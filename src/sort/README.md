# 排序算法

## O(n^2) 时间复杂度的排序算法

### 冒泡排序

#### 参考资料

[https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F](https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F)

#### 实现原理

1. 每次循环比较相邻的元素，如果前者比后者大，就交换两者
2. 对每一对相邻元素做完上面的操作之后，从开始第一对到最后一对，最后的元素应该是最大的值
3. 除了最后的值，重复做上面的操作

#### 瓶颈与优化

如果在一次子循环中没有做任何的交换操作，则排序已经结束，因为两两比较没有做任何的交换：**本质上数组已经有序**

主要的瓶颈在于**交换的次数过多，会消耗过多的时间**，影响时间复杂度的判断

### 选择排序

#### 实现原理

1. 每次子循环获取剩下值中最小值的位置，和当前比较位置进行交换
2. 每次子循环结束之后，就可以确定当前剩下内容中的最小值
3. 除了最后的值，重复做上面的操作

#### 瓶颈与优化

每次只在子循环**结束**，获取到**最小值位置**之后，**进行一次交换操作**，所以在整个排序过程中，**只会有 n 次交换操作**

### 插入排序

#### 实现原理

类似打扑克的洗牌效果

1. 插入排序是将数组拆分成已排序完成 & 待排序的两个模块
2. 每次取出待排序模块中的第一个值，向前寻找它位于已排序完成的模块中的位置
3. 不断**交换位置**以寻找真正应放置的位置，寻找到合适位置之后，**子循环可以提前结束**
4. 除了最后的值，重复做上面的操作

#### 瓶颈与优化

子循环中寻找合适位置的操作，**本质上就是在比较之后，与已排序完成的元素进行位置交换**，位置交换会带来时间 & 空间的损耗

但是在子循环中，一旦寻找到合适位置，子循环可以**提前结束**，所以插入排序在排序已**基本有序**数组的时候，时间复杂度会大幅降低，**趋向于 n**

### 希尔排序

``` javascript
// @TODO: 这个需要去学习下
```

## O(nlogn) 时间复杂度的排序算法

### 归并排序

### 快速排序

## 堆排序
