# 排序算法

## O(n^2) 时间复杂度的排序算法

### 冒泡排序

#### 参考资料

[https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F](https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F)

#### 实现原理

1. 每次循环比较相邻的元素，如果前者比后者大，就交换两者
2. 对每一对相邻元素做完上面的操作之后，从开始第一对到最后一对，最后的元素应该是最大的值
3. 除了最后的值，重复做上面的操作

#### 瓶颈与优化

如果在一次子循环中没有做任何的交换操作，则排序已经结束，因为两两比较没有做任何的交换：**本质上数组已经有序**

主要的瓶颈在于**交换的次数过多，会消耗过多的时间**，影响时间复杂度的判断

### 选择排序

#### 实现原理

1. 每次子循环获取剩下值中最小值的位置，和当前比较位置进行交换
2. 每次子循环结束之后，就可以确定当前剩下内容中的最小值
3. 除了最后的值，重复做上面的操作

#### 瓶颈与优化

每次只在子循环**结束**，获取到**最小值位置**之后，**进行一次交换操作**，所以在整个排序过程中，**只会有 n 次交换操作**

### 插入排序

#### 实现原理

类似打扑克的洗牌效果

1. 插入排序是将数组拆分成已排序完成 & 待排序的两个模块
2. 每次取出待排序模块中的第一个值，向前寻找它位于已排序完成的模块中的位置
3. 不断**交换位置**以寻找真正应放置的位置，寻找到合适位置之后，**子循环可以提前结束**
4. 除了最后的值，重复做上面的操作

#### 瓶颈与优化

子循环中寻找合适位置的操作，**本质上就是在比较之后，与已排序完成的元素进行位置交换**，位置交换会带来时间 & 空间的损耗

但是在子循环中，一旦寻找到合适位置，子循环可以**提前结束**，所以插入排序在排序已**基本有序**数组的时候，时间复杂度会大幅降低，**趋向于 n**

### 希尔排序

``` javascript
// @TODO: 这个需要去学习下
```

## O(nlogn) 时间复杂度的排序算法

归并 & 快排 本质上都是 **分治算法** 思想的体现

分治算法：就是**将原问题分隔成同等结构的子问题**，之后将子问题逐一解决之后，原问题也就得到了解决

- 归并排序：拆分子流程很简单，只是每次一分为二，而合并子流程时就需要有序化处理；
- 快速排序：每次拆分子流程就将数组基于标识位拆分成了两部分，拆分过程包含了排序的处理；

### 归并排序

#### 实现原理

有两种实现的思路：递归 & 循环

1. 不断将数组拆分成平均的两个模块
2. 拆分到最细时，每个模块元素个数应该都是 1
3. 向上回溯，每次**合并两个模块，将左右两个已经有序的模块合并成一整个有序的模块**
4. 不断回溯到最后的结果

循环的实现原理如下：

1. 外层循环是每次增加步长，从 1 开始，每次循环 * 2 或者是 累加，步长就是每次子循环中已有序的数组长度
2. 子循环就是基于步长，两步长为一组，将已经有序的两组数据，排序合并到一起
3. 需要关注临界情况

#### 瓶颈与优化

因为归并排序拆分子流程是简单的一分为二，所以主要的优化手段应用在将两模块合并时的操作

1. 每次将两个模块合并的时候，**可以判断是不是这两个模块已经完全有序**了，只需要判断左侧末尾是不是小于右侧开头，这样可以避免一次合并操作
2. 少量数据的情况下，直接使用插入排序取代归并来优化时间复杂度

### 快速排序

#### 实现原理

区别于归并排序递归实现，快速排序实际上是**自顶向下**的排序方式

1. 每次递归中，**随机**获取一位置上值为**标识位**，然后基于**标识位**将当前递归中的数据模块拆分成：小于、等于、大于，三个模块的数据
2. 递归快排 小于 & 等于 两块的数据集

#### 瓶颈与优化

快速排序的主要优化应用在如何将模块数据拆分成 小于、等于、大于 三个模块

1. **标识位的选取最好是中位数**，防止递归树变得偏向一侧，时间复杂度走向极端，所以这边采用**随机选择**的方式
2. 将数据模块拆分成 小于、等于、大于 三个模块 或者 是 小于等于、大于等于 两个模块，避免**过量相等数据**造成递归树偏向一侧的影响
3. 少量数据的情况下，直接使用插入排序取代快排来优化时间复杂度

## 堆排序
